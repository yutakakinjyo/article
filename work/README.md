# Slave of Program

生産性の高いプログラマとそうでないプログラマの違いがなにかというのを考えます。  
結論からいうと  

- 生産性の高いプログラマは**プログラムを掌握して使いこなしている**  
- 生産性の低いプログラムは**プログラムの奴隷となって使われている**  

そんな表現ができるのではないかと思いました。  

## 掌握と奴隷の違い

例えば、テストコードを書くか書かないかで表現できるように思えます。  

### 手動テスト

プログラムを変更する毎に手動でテストを行います。変更が他の動作に影響がないか調べるために、他のコードのテストも行います。  
テスト内容はドキュメントで管理され、人がそのドキュメントに沿ってテストを行います。  

### 自動テスト

プログラムを変更する毎にテストコードを書き、テストを自動で実行します。変更が他の動作に影響がないか調べるために、他のコードも自動テストします。  
テスト内容はコードで管理され、人は自動テストを実行して、テストを行います。  

### コストの違い

手動テストのコストは**労働力**と**時間**です。人が手動でテストを行うために、テストを行う労働力と時間が必要です。  
自動テストのコストは**労働力**と**学習時間**です。テストコードを書く労働力と、テストコードを書くための知識を蓄えるための学習時間が必要です。  

この２つのコストの違いは「スケールするか、しないか」と言えると思います。  

**自動テストのほうが手動テストよりもスケールします**

- 手動テストはコードの規模と相関するだけの労働力と時間が必要です  
- 自動テストはコードの規模と相関するだけの労働力が必要です。  

学習時間はテストコードを書き始める最初に必要ですが、一度テストコードの書き方が分かれば、その学習コストは落ち着きます。コードの規模とは相関しません。  
コード量が多い場合には以下のような関係になります。  

`労働力*コード量 + 時間*コード量 > 労働力*コード量 + 学習時間`

- コード量に関係する時間を学習時間で掌握して、相関関係を無くすの人が、**プログラムを掌握して使いこなしている**プログラマです 
- コード量に追従して、時間を使う人が、**プログラムの奴隷となって使われている**プログラマです。

### 細かい変数達

上のコスト関係はかなり大雑把に表現したものです。現実にはさらに変数が多くなります。

- コードの量とテストの量は一対一ではない。なので単純な掛け算にはならない。
- 学習時間はコードの量と関係する場合がある。なので、単純に学習時間を足すだけではない。
- 手動テストと自動テストの労働力は値が違う。なので、同じ労働力という変数では表せない

これらのことより、手動と自動テストのコストの関係は、以下のような状況下で働きます

- 1:1 = コード量:テスト量
- 学習時間はコード量とまったく相関しない
- 手動テストの労働コスト = 自動テストの労働コスト
